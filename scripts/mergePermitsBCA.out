
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # mergePermitsBCA.R
> # Merge Vancouver permit data directly with BC Assessment data
> # Replaces the two-step parcel intermediate merge with a direct join
> 
> library(data.table)
Warning message:
package ‘data.table’ was built under R version 4.4.1 
> library(RSQLite)
> 
> # ============================================================================
> # Configuration
> # ============================================================================
> 
> directory <- "~/OneDrive - UBC/dataRaw"
> bcaFile <- file.path(directory, "REVD19_and_inventory_extracts.sqlite3")
> outputDir <- "~/OneDrive - UBC/dataProcessed"
> 
> f_permit <- "vancouver_permits_full.csv"
> 
> # ============================================================================
> # Address Standardization
> # ============================================================================
> 
> # Street type abbreviation mappings
> streetRename <- data.table(
+   short = c(" ST", " AVE", " AV", " RD", " DR", " BLVD", " CRES", " HWY", " PL", " PLZ"),
+   long = c(" STREET", " AVENUE", " AVENUE", " ROAD", " DRIVE", " BOULEVARD", " CRESCENT", " HIGHWAY", " PLACE", " PLAZA")
+ )
> 
> standardizeAddress <- function(dt, addressCol = "address") {
+   # Work on a copy of the column to avoid side effects
+   dt[, (addressCol) := toupper(get(addressCol))]
+   
+   # Remove city/province suffix and postal codes
+   dt[, (addressCol) := gsub(", Vancouver, BC", "", get(addressCol), ignore.case = TRUE)]
+   dt[, (addressCol) := gsub(" V[0-9][A-Z] [0-9][A-Z][0-9]$", "", get(addressCol))]
+   
+   # Standardize street types (at end of string and before space)
+   for (i in seq_len(nrow(streetRename))) {
+     pattern_end <- paste0(streetRename$short[i], "$")
+     pattern_mid <- paste0(streetRename$short[i], " ")
+     replacement_mid <- paste0(streetRename$long[i], " ")
+     
+     dt[, (addressCol) := gsub(pattern_end, streetRename$long[i], get(addressCol))]
+     dt[, (addressCol) := gsub(pattern_mid, replacement_mid, get(addressCol))]
+   }
+   
+   invisible(dt)
+ }
> 
> # ============================================================================
> # Load Permit Data
> # ============================================================================
> 
> cat("Loading permit data...\n")
Loading permit data...
> dtPermits <- fread(file.path(directory, f_permit))
> 
> # Create grouping variable for permits from same applicant/month
> dtPermits[, grouper := paste0(yearmonth, applicant)]
> 
> # Parse coordinates and compute within-group distance
> dtPermits[, c("lat", "lon") := tstrsplit(geo_point_2d, ",\\s*", type.convert = TRUE)]
> dtPermits[, groupDistance := {
+   lon_adj <- cos(mean(lat, na.rm = TRUE) * pi / 180)
+   sqrt(var(lat, na.rm = TRUE) + var(lon * lon_adj, na.rm = TRUE)) * 111000
+ }, by = grouper]
> 
> # Split groups that are geographically dispersed (>25m)
> dtPermits[, nGroup := .N, by = grouper]
> dtPermits[, group2 := grouper]
> dtPermits[groupDistance > 25, group2 := paste0(grouper, "_", .I)]
> 
> cat("Permits loaded:", nrow(dtPermits), "rows,", uniqueN(dtPermits$grouper), "groups\n")
Permits loaded: 49093 rows, 32434 groups
> 
> # Standardize permit addresses
> standardizeAddress(dtPermits, "address")
> 
> # ============================================================================
> # Load BCA Data (2019 SQLite)
> # ============================================================================
> 
> cat("Loading BCA data from SQLite...\n")
Loading BCA data from SQLite...
> 
> con <- dbConnect(SQLite(), bcaFile)
> 
> # Load address table filtered to Vancouver, joined with folioDescription
> # to restrict to Single Family Dwelling and Residential Dwelling with Suite
> dtAddress <- as.data.table(dbGetQuery(con, "
+   SELECT a.folioID, a.addressID, a.primaryFlag, a.streetNumber, a.unitNumber,
+          a.streetDirectionPrefix, a.streetName, a.streetDirectionSuffix, a.streetType,
+          a.city, a.postalCode
+   FROM address a
+   INNER JOIN folioDescription fd ON a.folioID = fd.folioID
+   WHERE a.city = 'VANCOUVER'
+     AND fd.actualUseDescription IN ('Single Family Dwelling', 'Residential Dwelling with Suite')
+ "))
> 
> # Load folio description - filtered to target actual uses
> dtDescription <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, actualUseCode, actualUseDescription,
+          landDimensionType, landDimensionTypeDescription,
+          landDimension, landWidth, landDepth,
+          neighbourhoodCode, neighbourhoodDescription
+   FROM folioDescription
+   WHERE actualUseDescription IN ('Single Family Dwelling', 'Residential Dwelling with Suite')
+ "))
> 
> # Load valuation data
> dtValuation <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, propertyClassCode, propertyClassDescription,
+          landValue, improvementValue
+   FROM valuation
+ "))
> 
> # Load legal description for PID
> dtLegal <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, PID, formattedLegalDescription
+   FROM legalDescription
+ "))
> 
> # Load folio for roll number (needed to join residential inventory)
> dtFolio <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, jurisdictionCode, rollNumber
+   FROM folio
+ "))
> 
> # Load residential inventory (join via roll_number)
> dtResidential <- as.data.table(dbGetQuery(con, "
+   SELECT roll_number, MB_year_built, MB_effective_year, MB_total_finished_area,
+          MB_num_storeys, num_bedrooms, num_full_baths
+   FROM residentialInventory
+ "))
> 
> dbDisconnect(con)
> 
> # Merge BCA tables
> dtBCA <- merge(dtAddress, dtDescription, by = "folioID", all.x = TRUE)
> dtBCA <- merge(dtBCA, dtValuation, by = "folioID", all.x = TRUE)
> dtBCA <- merge(dtBCA, dtLegal, by = "folioID", all.x = TRUE)
> dtBCA <- merge(dtBCA, dtFolio, by = "folioID", all.x = TRUE)
> 
> # Join residential inventory via roll_number
> setnames(dtResidential, "roll_number", "rollNumber")
> dtBCA <- merge(dtBCA, dtResidential, by = "rollNumber", all.x = TRUE)
> 
> cat("BCA records loaded:", nrow(dtBCA), "\n")
BCA records loaded: 96367 
> 
> # Create standardized address from BCA components
> dtBCA[, address := paste(streetNumber, streetName)]
> dtBCA[nchar(streetDirectionPrefix) > 0, address := paste(streetNumber, streetDirectionPrefix, streetName)]
> dtBCA[nchar(streetType) > 0, address := paste(address, streetType)]
> 
> standardizeAddress(dtBCA, "address")
> 
> # ============================================================================
> # Merge Permits with BCA
> # ============================================================================
> 
> cat("Merging permits with BCA data...\n")
Merging permits with BCA data...
> 
> dtMerge <- merge(dtPermits, dtBCA, by = "address", all.x = TRUE)
> 
> # Flag whether each permit matched
> dtMerge[, matched := !is.na(folioID)]
> 
> # For each group, check if ANY permit matched
> dtMerge[, groupHasMatch := any(matched), by = group2]
> 
> # ============================================================================
> # Group-level matching: keep only matched permits when group has a match
> # ============================================================================
> 
> # If a group has at least one match, drop the unmatched permits in that group
> # (e.g., 1244, 1246, 1248 W 14th - if only 1246 matches, keep only 1246)
> dtMergeFiltered <- dtMerge[matched == TRUE | groupHasMatch == FALSE]
> 
> cat("\nAfter group filtering:\n")

After group filtering:
> cat("  Original permits:", nrow(dtMerge), "\n")
  Original permits: 49205 
> cat("  Filtered permits:", nrow(dtMergeFiltered), "\n")
  Filtered permits: 48664 
> cat("  Dropped (unmatched in groups with matches):", nrow(dtMerge) - nrow(dtMergeFiltered), "\n")
  Dropped (unmatched in groups with matches): 541 
> 
> # ============================================================================
> # Match Statistics by Project Type
> # ============================================================================
> 
> cat("\n=== Match Statistics by Project Type ===\n")

=== Match Statistics by Project Type ===
> 
> # Compute at PERMIT level first
> permitStats <- dtMerge[, .(
+   n_permits = .N,
+   n_matched = sum(matched),
+   pct_matched = round(mean(matched) * 100, 1)
+ ), by = typeofwork][order(-n_permits)]
> 
> cat("\nBy typeofwork (permit-level):\n")

By typeofwork (permit-level):
> print(permitStats)
                             typeofwork n_permits n_matched pct_matched
                                 <char>     <int>     <int>       <num>
1:                Addition / Alteration     24020      2076         8.6
2:                         New Building     11261      2554        22.7
3:                Salvage and Abatement      6752      2279        33.8
4:          Demolition / Deconstruction      6648      2236        33.6
5:       Temporary Building / Structure       462         2         0.4
6: Outdoor Uses (No Buildings Proposed)        62         8        12.9
> 
> # Compute at GROUP level (did the group get at least one match?)
> # This is the right denominator for multiplex projects
> groupStats <- dtMerge[, .(
+   groupHasMatch = first(groupHasMatch),
+   typeofwork = first(typeofwork),
+   n_permits_in_group = .N
+ ), by = group2]
> 
> groupStatsSummary <- groupStats[, .(
+   n_groups = .N,
+   n_matched = sum(groupHasMatch),
+   pct_matched = round(mean(groupHasMatch) * 100, 1)
+ ), by = typeofwork][order(-n_groups)]
> 
> cat("\nBy typeofwork (group-level, at least one match):\n")

By typeofwork (group-level, at least one match):
> print(groupStatsSummary)
                             typeofwork n_groups n_matched pct_matched
                                 <char>    <int>     <int>       <num>
1:                Addition / Alteration    23065      2011         8.7
2:                         New Building     9037      2160        23.9
3:                Salvage and Abatement     6236      2155        34.6
4:          Demolition / Deconstruction     4957      1628        32.8
5:       Temporary Building / Structure      449         2         0.4
6: Outdoor Uses (No Buildings Proposed)       59         7        11.9
> 
> # If specificusecategory exists, show that too
> if ("specificusecategory" %in% names(dtMerge)) {
+   groupStatsCategory <- dtMerge[, .(
+     groupHasMatch = first(groupHasMatch),
+     specificusecategory = first(specificusecategory),
+     n_permits_in_group = .N
+   ), by = group2]
+   
+   categoryStats <- groupStatsCategory[, .(
+     n_groups = .N,
+     n_matched = sum(groupHasMatch),
+     pct_matched = round(mean(groupHasMatch) * 100, 1)
+   ), by = specificusecategory][order(-n_groups)]
+   
+   cat("\nBy specificusecategory (group-level):\n")
+   print(head(categoryStats, 30))
+ }

By specificusecategory (group-level):
                         specificusecategory n_groups n_matched pct_matched
                                      <char>    <int>     <int>       <num>
 1:                    Single Detached House    11702      4428        37.8
 2:                        Multiple Dwelling     5858       106         1.8
 3:        Single Detached House w/Sec Suite     4954      1822        36.8
 4:                           General Office     4744         0         0.0
 5:                            Laneway House     3226       568        17.6
 6:                             Retail Store     1835         1         0.1
 7:                                   Duplex     1714       456        26.6
 8:                     Restaurant - Class 1      885         0         0.0
 9:                            Dwelling Unit      667        74        11.1
10:                 Duplex w/Secondary Suite      591       246        41.6
11:                       Health Care Office      565         0         0.0
12:                           Not Applicable      423        12         2.8
13:             Multiple Conversion Dwelling      322        50        15.5
14:                                 Hospital      244         1         0.4
15:               Beauty and Wellness Centre      214         0         0.0
16:                    Financial Institution      198         0         0.0
17:                       Park or Playground      190         4         2.1
18:         School - Elementary or Secondary      172         0         0.0
19:              Barber Shop or Beauty Salon      161         0         0.0
20:             Infill Single Detached House      153        28        18.3
21: Duplex w/Secondary Suite,Secondary Suite      143        59        41.3
22:                    Wholesaling - Class A      137         0         0.0
23:           School - University or College      134         0         0.0
24:                                   Church      105         2         1.9
25:                           Fitness Centre      105         0         0.0
26:                                    Hotel      103         0         0.0
27:                        Storage Warehouse       96         0         0.0
28:        School - Arts or Self-Improvement       95         0         0.0
29:              General Office,Retail Store       93         0         0.0
30:       Community Ctr./Neighbourhood House       80         0         0.0
                         specificusecategory n_groups n_matched pct_matched
> 
> # Overall stats
> cat("\n=== Overall ===\n")

=== Overall ===
> cat("Permit-level match rate:", round(mean(dtMerge$matched) * 100, 1), "%\n")
Permit-level match rate: 18.6 %
> cat("Group-level match rate:", round(mean(groupStats$groupHasMatch) * 100, 1), "%\n")
Group-level match rate: 18.2 %
> 
> # ============================================================================
> # Output
> # ============================================================================
> 
> # Select relevant columns for output (using filtered data)
> outputCols <- intersect(
+   c("address", "permitnumber", "yearmonth", "applicant", "propertyuse", 
+     "specificusecategory", "typeofwork", "projectvalue", "lat", "lon",
+     "grouper", "group2", "groupDistance",
+     "folioID", "rollNumber", "PID", "actualUseCode", "actualUseDescription",
+     "landDimension", "landWidth", "landDepth", 
+     "neighbourhoodCode", "neighbourhoodDescription",
+     "propertyClassCode", "propertyClassDescription",
+     "landValue", "improvementValue",
+     "MB_year_built", "MB_effective_year", "MB_total_finished_area",
+     "MB_num_storeys", "num_bedrooms", "num_full_baths"),
+   names(dtMergeFiltered)
+ )
> 
> dtOutput <- dtMergeFiltered[, ..outputCols]
> 
> outFile <- file.path(outputDir, "mergePermitsBCA.csv")
> fwrite(dtOutput, outFile)
> cat("\nOutput written to:", outFile, "\n")

Output written to: ~/OneDrive - UBC/dataProcessed/mergePermitsBCA.csv 
> cat("Output rows:", nrow(dtOutput), "\n")
Output rows: 48664 
> 
> # ============================================================================
> # Summary Statistics
> # ============================================================================
> 
> cat("\n=== Actual Use Distribution (matched permits) ===\n")

=== Actual Use Distribution (matched permits) ===
> print(table(dtMergeFiltered[matched == TRUE, actualUseDescription]))

Residential Dwelling with Suite          Single Family Dwelling 
                           4063                            5092 
> 
> cat("\n=== Unmatched and matched address patterns (last word) ===\n")

=== Unmatched and matched address patterns (last word) ===
> dtMerge[,lastWord := sub(".* ([^ ]+)$", "\\1", address)]
> dtUnmatched <- dtMerge[matched == FALSE & groupHasMatch == FALSE]
> print(head(sort(table(dtUnmatched$lastWord), decreasing = TRUE), 20))

   AVENUE    STREET        #3     DRIVE  BROADWAY  KINGSWAY       WAY           
    18136     13367      1518      1073       977       377       192       183 
    PLACE BOULEVARD      ROAD  CRESCENT     NORTH   HIGHWAY      #301      #101 
      160       159       135       123        68        52        49        48 
     #102      #303     SOUTH      #201 
       45        43        41        40 
> print(head(sort(table(dtMerge[matched==TRUE | groupHasMatch==TRUE,lastWord]), decreasing = TRUE), 20))

   STREET     DRIVE    AVENUE  CRESCENT        #3     PLACE      ROAD           
     7489       868       716       222       131       104        91        25 
BOULEVARD       WAY     NORTH     CLOSE   HIGHWAY      #PH6      #PH9 
       25        11         8         2         2         1         1 
> 
> 
> proc.time()
   user  system elapsed 
 43.690   2.365  24.051 
