
R version 4.5.0 (2025-04-11) -- "How About a Twenty-Six"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # mergePermitsZoningBCA.R
> # Merge Vancouver permits with: Zoning, Census Tracts, and BC Assessment data
> # Uses BCA parcel polygons for spatial matching, BCA 2019 for property details
> # Tom Davidoff / Claude
> # 01/15/26
> 
> library(sf)
Linking to GEOS 3.13.0, GDAL 3.8.5, PROJ 9.5.1; sf_use_s2() is TRUE
> library(data.table)
> library(RSQLite)
> 
> # ============================================================================
> # Configuration
> # ============================================================================
> 
> directory   <- "~/OneDrive - UBC/dataRaw"
> outputDir   <- "~/OneDrive - UBC/dataProcessed"
> 
> permits_path <- file.path(directory, "vancouver_permits_full.csv")
> zoning_path  <- file.path(directory, "vancouver_zoning.geojson")
> ct_file      <- file.path(directory, "lct_000b21a_e/lct_000b21a_e.shp")
> bcaFile19    <- file.path(directory, "REVD19_and_inventory_extracts.sqlite3")
> bcaFileGeo <- "~/OneDrive - UBC/dataProcessed/bca_vancouver_residential.rds"
> 
> out_path     <- file.path(outputDir, "permits_zoning_ct_bca.csv")
> 
> # ============================================================================
> # STEP 1: Load Permits
> # ============================================================================
> 
> cat("=== STEP 1: Loading permits ===\n")
=== STEP 1: Loading permits ===
> dtPermits <- fread(permits_path, drop = "projectdescription")
> 
> # Parse coordinates
> ll <- tstrsplit(gsub("\\s+", "", dtPermits$geo_point_2d), ",", fixed = TRUE)
> dtPermits[, `:=`(lat = as.numeric(ll[[1]]), lon = as.numeric(ll[[2]]))]
> dtPermits <- dtPermits[!is.na(lat) & !is.na(lon)]
> 
> cat("Permits loaded:", nrow(dtPermits), "\n")
Permits loaded: 48753 
> 
> # ============================================================================
> # STEP 2: Project-level grouping (same applicant/month within 25m)
> # ============================================================================
> 
> cat("\n=== STEP 2: Creating project groups ===\n")

=== STEP 2: Creating project groups ===
> 
> # Group by applicant + yearmonth
> dtPermits[, grouper := paste0(yearmonth, applicant)]
> 
> # Compute within-group geographic spread
> dtPermits[, groupDistance := {
+   lon_adj <- cos(mean(lat, na.rm = TRUE) * pi / 180)
+   sqrt(var(lat, na.rm = TRUE) + var(lon * lon_adj, na.rm = TRUE)) * 111000
+ }, by = grouper]
> 
> # Split dispersed groups (>25m spread)
> dtPermits[, nGroup := .N, by = grouper]
> dtPermits[, projectID := grouper]
> dtPermits[groupDistance > 25, projectID := paste0(grouper, "_", .I)]
> 
> cat("Unique projects:", uniqueN(dtPermits$projectID), "\n")
Unique projects: 43572 
> 
> # ============================================================================
> # STEP 3: Spatial join with Zoning
> # ============================================================================
> 
> cat("\n=== STEP 3: Joining with zoning ===\n")

=== STEP 3: Joining with zoning ===
> 
> sZoning <- st_read(zoning_path, quiet = TRUE)
> 
> sPermits <- st_as_sf(dtPermits, coords = c("lon", "lat"), crs = 4326, remove = FALSE)
> sPermits <- st_transform(sPermits, st_crs(sZoning))
> sPermits <- st_join(sPermits, sZoning[, c("zoning_district", "zoning_category", "zoning_classification")], 
+                     join = st_within)
> 
> cat("Permits with zoning attached\n")
Permits with zoning attached
> 
> # ============================================================================
> # STEP 4: Spatial join with Census Tracts
> # ============================================================================
> 
> cat("\n=== STEP 4: Joining with census tracts ===\n")

=== STEP 4: Joining with census tracts ===
> 
> # City of Vancouver boundary (to clip census tracts)
> cov_url <- "https://opendata.vancouver.ca/api/explore/v2.1/catalog/datasets/city-boundary/exports/geojson"
> sCoV <- st_read(cov_url, quiet = TRUE)
> sCoV <- st_make_valid(sCoV)
> sCoV <- st_union(sCoV)
> 
> # Census tracts
> sCT <- st_read(ct_file, quiet = TRUE)
> sCT <- st_make_valid(sCT)
> sCT <- st_transform(sCT, st_crs(sCoV))
> sCT_cov <- st_intersection(sCT, st_make_valid(sCoV))
Warning message:
attribute variables are assumed to be spatially constant throughout all geometries 
> 
> # Join permits with census tracts
> sPermits <- st_transform(sPermits, st_crs(sCT_cov))
> sPermits <- st_join(sPermits, sCT_cov[, c("CTUID", "DGUID", "CTNAME")], join = st_within)
> 
> cat("Permits with census tract attached\n")
Permits with census tract attached
> 
> # ============================================================================
> # STEP 5: Load BCA parcel polygons
> # ============================================================================
> 
> cat("\n=== STEP 5: Loading BCA parcel polygons ===\n")

=== STEP 5: Loading BCA parcel polygons ===
> 
> # Load Vancouver residential parcels with geometry
> sBCA <- readRDS(bcaFileGeo)
> 
> cat("BCA geo parcels loaded:", nrow(sBCA), "\n")
BCA geo parcels loaded: 79717 
> 
> # Add roll_base for linking to BCA 2019 data
> sBCA$roll_base <- floor(as.numeric(sBCA$ROLL_NUMBER) / 1000)
> 
> # ============================================================================
> # STEP 6: Load BCA 2019 property details
> # ============================================================================
> 
> cat("\n=== STEP 6: Loading BCA 2019 property details ===\n")

=== STEP 6: Loading BCA 2019 property details ===
> 
> con <- dbConnect(SQLite(), bcaFile19)
> 
> dtDescription <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, actualUseCode, actualUseDescription,
+          landDimension, landWidth, landDepth,
+          neighbourhoodCode, neighbourhoodDescription
+   FROM folioDescription
+   WHERE actualUseDescription IN ('Single Family Dwelling', 'Residential Dwelling with Suite')
+ "))
> 
> dtValuation <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, propertyClassCode, propertyClassDescription,
+          landValue, improvementValue
+   FROM valuation
+ "))
> 
> dtLegal <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, PID
+   FROM legalDescription
+ "))
> 
> dtFolio <- as.data.table(dbGetQuery(con, "
+   SELECT folioID, rollNumber
+   FROM folio
+ "))
> 
> dtResidential <- as.data.table(dbGetQuery(con, "
+   SELECT roll_number, MB_year_built, MB_effective_year, MB_total_finished_area,
+          MB_num_storeys, num_bedrooms, num_full_baths
+   FROM residentialInventory
+ "))
> 
> dbDisconnect(con)
> 
> # Merge BCA 2019 tables
> dtBCA19 <- merge(dtDescription, dtValuation, by = "folioID", all.x = TRUE)
> dtBCA19 <- merge(dtBCA19, dtLegal, by = "folioID", all.x = TRUE)
> dtBCA19 <- merge(dtBCA19, dtFolio, by = "folioID", all.x = TRUE)
> setnames(dtResidential, "roll_number", "rollNumber")
> dtBCA19 <- merge(dtBCA19, dtResidential, by = "rollNumber", all.x = TRUE)
> 
> # Add roll_base for joining
> dtBCA19[, roll_base := floor(as.numeric(rollNumber) / 1000)]
Warning message:
In eval(jsub, SDenv, parent.frame()) : NAs introduced by coercion
> 
> cat("BCA 2019 records loaded:", nrow(dtBCA19), "\n")
BCA 2019 records loaded: 2553227 
> 
> # ============================================================================
> # STEP 7: Spatial join - permits to BCA parcels (point in polygon)
> # ============================================================================
> 
> cat("\n=== STEP 7: Spatial join - permits within BCA parcels ===\n")

=== STEP 7: Spatial join - permits within BCA parcels ===
> 
> # Transform permits to BCA CRS
> sPermits_bca <- st_transform(sPermits, st_crs(sBCA))
> 
> # Make geometries valid
> sBCA<- st_make_valid(sBCA)
> 
> # Spatial join: permit points within BCA parcel polygons
> sPermits_bca <- st_join(sPermits_bca, sBCA[, c("ROLL_NUMBER", "roll_base")], 
+                         join = st_within, left = TRUE)
> 
> cat("Spatial join complete\n")
Spatial join complete
> cat("Permits matched to BCA parcel:", sum(!is.na(sPermits_bca$ROLL_NUMBER)), "\n")
Permits matched to BCA parcel: 23781 
> cat("Permits not matched:", sum(is.na(sPermits_bca$ROLL_NUMBER)), "\n")
Permits not matched: 26099 
> 
> # ============================================================================
> # STEP 8: Merge BCA 2019 property details via roll_base
> # ============================================================================
> 
> cat("\n=== STEP 8: Merging BCA 2019 property details ===\n")

=== STEP 8: Merging BCA 2019 property details ===
> 
> # Convert to data.table
> dtMerge <- as.data.table(st_drop_geometry(sPermits_bca))
> 
> # Select columns to merge from BCA 2019 (exclude roll_base to avoid .x/.y)
> bcaCols <- c("roll_base", "folioID", "rollNumber", "PID", 
+              "actualUseCode", "actualUseDescription",
+              "landDimension", "landWidth", "landDepth",
+              "neighbourhoodCode", "neighbourhoodDescription",
+              "propertyClassCode", "propertyClassDescription",
+              "landValue", "improvementValue",
+              "MB_year_built", "MB_effective_year", "MB_total_finished_area",
+              "MB_num_storeys", "num_bedrooms", "num_full_baths")
> 
> dtBCA19_slim <- dtBCA19[, ..bcaCols]
> 
> # Merge on roll_base
> dtMerge <- merge(dtMerge, dtBCA19_slim, by = "roll_base", all.x = TRUE)
Error in vecseq(f__, len__, if (allow.cartesian || notjoin || !anyDuplicated(f__,  : 
  Join results in 1612576972 rows; more than 2603107 = nrow(x)+nrow(i). Check for duplicate key values in i each of which join to the same group in x over and over again. If that's ok, try by=.EACHI to run j for each group to avoid the large allocation. If you are sure you wish to proceed, rerun with allow.cartesian=TRUE. Otherwise, please search for this error message in the FAQ, Wiki, Stack Overflow and data.table issue tracker for advice.
Calls: merge -> merge.data.table -> [ -> [.data.table -> vecseq
Execution halted
